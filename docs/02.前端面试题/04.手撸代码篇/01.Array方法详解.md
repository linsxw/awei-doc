---
title: Array方法详解
date: 2022-05-31 14:01:29
permalink: /pages/6e9437/
---


## 介绍

[官方文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)


## Array.prototype.at()

`at()` 方法接收一个整数值并返回该索引的值，允许正数和负数。负整数从数组中的最后一项开始倒数。

访问数组依然使用`arr[index]`,则访问数组最后一项我们通常使用`arr[arr.length -1]`，使用`at()`则：`arr.at(-1)`

返回值： 匹配给定索引的数组中的元素。如果找不到指定的索引，则返回`undefined`。
上代码：

```js
const arr = [1, 2, 3, 4, 5];

console.log(arr.at(2)); // 输出3

// 获取数组最后一个的值
console.log(arr.at(-1)); // 输出5

// 找不到该索引下的值
console.log(arr.at(10)); // undefined

// 获取数组的最后一项元素
function getArrLastValue(arr) {
  return arr.at(-1);
}

// 剩下的自由发挥
```

## Array.prototype.concat()

`concat` 方法创建一个新的数组，它由被调用的对象中的元素组成，每个参数的顺序依次是该参数的元素（如果参数是数组）或参数本身（如果参数不是数组）。它不会递归到嵌套数组参数中。

语法：`arr.concat(arr/value...)`

::: tip 备注
数组/值在连接时保持不变。此外，对于新数组的任何操作（仅当元素不是对象引用时）都不会对原始数组产生影响，反之亦然。
:::

上代码：

```js
// 合并2个数组
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
console.log(arr1.concat(arr2)); //输出[1,2,3,4,5,6]

// 合并3个数组
const arr3 = [7];
console.log(arr1.concat(arr2, arr3)); //输出[1,2,3,4,5,6,7]

// 将值合并到数组
console.log(arr1.concat(100, [12, 22])); // [1,2,3,100,12,22]
```

## Array.prototype.every()

`every()` 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。

::: tip 备注
若收到一个空数组，此方法在任何情况下都会返回 `true`。
:::

`callback` 在被调用时可传入三个参数：元素值，元素的索引，原数组

上代码：

```js
// 判断是否成年
const whetherAdult = (age) => age >= 18;
const ages = [19, 20, 22, 21];
console.log(ages.every(whetherAdult)); // true

ages.push(13);
console.log(ages.every(whetherAdult)); // false

// 使用箭头函数
const isAdult = ages.every((age) => age >= 18);
```

## Array.prototype.fill()

`fill()` 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。

语法：`arr.fill(value, start ,end)`

::: tip 备注
方法会改变原数组
:::

```js
[1, 2, 3].fill(4); // [4, 4, 4]
[1, 2, 3].fill(4, 1); // [1, 4, 4]
[1, 2, 3].fill(4, 1, 2); // [1, 4, 3]
[1, 2, 3].fill(4, 1, 1); // [1, 2, 3]
[1, 2, 3].fill(4, 3, 3); // [1, 2, 3]
[1, 2, 3].fill(4, -3, -2); // [4, 2, 3]
[1, 2, 3].fill(4, NaN, NaN); // [1, 2, 3]
[1, 2, 3].fill(4, 3, 5); // [1, 2, 3]
```

## Array.prototype.filter()

`filter()` 方法创建一个新数组，其包含通过所提供函数实现的测试的所有元素。

语法： `arr.filter(callback(element, index?, array?), thisArg?)`

```js
const words = [
  "spray",
  "limit",
  "elite",
  "exuberant",
  "destruction",
  "present",
];

const result = words.filter((word) => word.length > 6);

console.log(result); // ["exuberant", "destruction", "present"]
```

## Array.prototype.find()

`find() `方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 `undefined`。

语法：`arr.find(callback[, thisArg])`

上代码：

```js
const animals = ["pig", "loin", "tiger", "monkey"];

const findMonkey = animals.find((animal) => animal === "monkey");

console.log(findMonkey); // "monkey"
```

## Array.prototype.findIndex()

`findIndex()`方法返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回-1。

语法：`arr.findIndex(callback,thisArg?)`

```js
const animals = ["pig", "loin", "tiger", "monkey"];

const findMonkeyIndex = animals.findIndex((animal) => animal === "monkey");

console.log(findMonkeyIndex); // 3
```

## Array.prototype.flat()

`flat()` 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。

语法：`var newArray = arr.flat(depth？)`

- depth 指定要提取嵌套数组的结构深度，默认值为 1。

```js
const arr1 = [0, 1, 2, [3, 4]];
console.log(arr1.flat()); // [0, 1, 2, 3, 4]

const arr2 = [0, 1, 2, [[[3, 4]]]];

console.log(arr2.flat(2)); // [0, 1, 2, [3, 4]]

var arr3 = [1, 2, [3, 4, [5, 6]]];
arr3.flat(2);
[1, 2, 3, 4, 5, 6];

//使用 Infinity，可展开任意深度的嵌套数组
var arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
arr4.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// 移除数组空项
var arr5 = [1, 2, , 4, 5];
arr5.flat(); // [1, 2, 4, 5]
```

## Array.prototype.forEach()

`forEach()` 方法对数组的每个元素执行一次给定的函数。

语法：`arr.forEach(callback(currentValue , index? ,array?), thisArg?)`

```js
const animals = ["pig", "loin", "tiger", "monkey"];
animals.forEach((item,index) => {
	console.log(item, index)
})
/*
> "pig" 0
> "loin" 1
> "tiger" 2
> "monkey" 3
 * /

```

## Array.from()

`Array.from()` 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。

语法：`Array.from(arrayLike, mapfn?, thisArg?)`

```js
// 从 String 生成数组
console.log(Array.from("foo")); // ["f", "o", "o"]

console.log(Array.from([1, 2, 3], (x) => x + x)); // [2, 4, 6]

// 从 Set 生成数组
const set = new Set(["foo", "bar", "baz", "foo"]);
Array.from(set); // [ "foo", "bar", "baz" ]

// 从 Map 生成数组

const map = new Map([
  [1, 2],
  [2, 4],
  [4, 8],
]);
Array.from(map);
// [[1, 2], [2, 4], [4, 8]]

const mapper = new Map([
  ["1", "a"],
  ["2", "b"],
]);
Array.from(mapper.values());
// ['a', 'b'];

Array.from(mapper.keys());
// ['1', '2'];
```

## Array.prototype.includes()

`includes()` 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 `true`，否则返回 `false`。

语法：`arr.includes(valueToFind, fromIndex?)`
返回值： `boolean`

```js
[1, 2, 3].includes(2); // true
[1, 2, 3].includes(4); // false
[1, 2, 3].includes(3, 3); // false
[1, 2, 3].includes(3, -1); // true
[1, 2, NaN].includes(NaN); // true
```

## Array.prototype.indexOf()

`indexOf` ()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。

语法：`arr.indexOf(searchElement, fromIndex?)`

```js
var array = [2, 5, 9];
array.indexOf(2); // 0
array.indexOf(7); // -1
array.indexOf(9, 2); // 2
array.indexOf(2, -1); // -1
array.indexOf(2, -3); // 0
```

## Array.isArray()

`Array.isArray()` 用于确定传递的值是否是一个 `Array`。

语法：`Array.isArray(obj)`
返回值：`boolean`

```js
// 下面的函数调用都返回 true
Array.isArray([]);
Array.isArray([1]);
Array.isArray(new Array());
Array.isArray(new Array("a", "b", "c", "d"));
// 鲜为人知的事实：其实 Array.prototype 也是一个数组。
Array.isArray(Array.prototype);

// 下面的函数调用都返回 false
Array.isArray();
Array.isArray({});
Array.isArray(null);
Array.isArray(undefined);
Array.isArray(17);
Array.isArray("Array");
Array.isArray(true);
Array.isArray(false);
Array.isArray(new Uint8Array(32));
Array.isArray({ __proto__: Array.prototype });
```

## Array.prototype.join()

`join() `方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。

语法：`arr.join(separator?)`

```js
var a = ["Wind", "Rain", "Fire"];
var myVar1 = a.join(); // myVar1 的值变为"Wind,Rain,Fire"
var myVar2 = a.join(", "); // myVar2 的值变为"Wind, Rain, Fire"
var myVar3 = a.join(" + "); // myVar3 的值变为"Wind + Rain + Fire"
var myVar4 = a.join(""); // myVar4 的值变为"WindRainFire"
```

## Array.prototype.keys()

`keys()` 方法返回一个包含数组中每个索引键的`Array Iterator`对象。

语法：`arr.keys()`

返回值：一个新的 `Array` 迭代器对象。

```js
var arr = ["a", , "c"];
var sparseKeys = Object.keys(arr);
var denseKeys = [...arr.keys()];
console.log(sparseKeys); // ['0', '2']
console.log(denseKeys); // [0, 1, 2]
```

## Array.prototype.lastIndexOf()

`lastIndexOf() `方法返回指定元素（也即有效的 `JavaScript` 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 `fromIndex` 处开始。

语法：`arr.lastIndexOf(searchElement, fromIndex?)`

返回值：数组中该元素最后一次出现的索引，如未找到返回-1。

```js
var array = [2, 5, 9, 2];
var index = array.lastIndexOf(2);
// index is 3
index = array.lastIndexOf(7);
// index is -1
index = array.lastIndexOf(2, 3);
// index is 3
index = array.lastIndexOf(2, 2);
// index is 0
index = array.lastIndexOf(2, -2);
// index is 0
index = array.lastIndexOf(2, -1);
// index is 3
```

## Array.prototype.map()

`map()` 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。

语法：`var new_array = arr.map(function callback(currentValue, index?, array?) {// return new arr}, thisArg)`

返回值：一个由原数组每个元素执行回调函数的结果组成的新数组。

```js
// 使用 map 重新格式化数组中的对象
var kvArray = [
  { key: 1, value: 10 },
  { key: 2, value: 20 },
  { key: 3, value: 30 },
];

var reformattedArray = kvArray.map(function (obj) {
  var rObj = {};
  rObj[obj.key] = obj.value;
  return rObj;
});

// reformattedArray 数组为： [{1: 10}, {2: 20}, {3: 30}],

// kvArray 数组未被修改：
// [{key: 1, value: 10},
//  {key: 2, value: 20},
//  {key: 3, value: 30}]

// 使用一个包含一个参数的函数来 mapping(构建) 一个数字数组
var numbers = [1, 4, 9];
var doubles = numbers.map(function (num) {
  return num * 2;
});

// doubles 数组的值为： [2, 8, 18]
// numbers 数组未被修改： [1, 4, 9]
```

## Array.of()

`Array.of()` 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。

`Array.of()` 和 `Array` 构造函数之间的区别在于处理整数参数：`Array.of(7)` 创建一个具有单个元素 7 的数组，而 `Array(7) `创建一个长度为 7 的空数组（注意：这是指一个有 7 个空位 (`empty`) 的数组，而不是由 7 个`undefined`组成的数组）。

```js
Array.of(7); // [7]
Array.of(1, 2, 3); // [1, 2, 3]

Array(7); // [ , , , , , , ]
Array(1, 2, 3); // [1, 2, 3]
```

语法：`Array.of(element0[, element1[, ...[, elementN]]])`

返回值：新的 Array 实例。

```js
Array.of(1); // [1]
Array.of(1, 2, 3); // [1, 2, 3]
Array.of(undefined); // [undefined]
```

## Array.prototype.pop()

`pop()` 方法从数组中删除最后一个元素，并返回该元素的值。此方法会更改数组的长度。

语法：`arr.pop()`

返回值：从数组中删除的元素（当数组为空时返回`undefined`）。

```js
// 删除掉数组的最后一个元素
const myFish = ["angel", "clown", "mandarin", "sturgeon"];

const popped = myFish.pop();

console.log(myFish); // ['angel', 'clown', 'mandarin']

console.log(popped); // 'sturgeon'
```

## Array.prototype.push()

`push()` 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。

语法：`arr.push(element1, ..., elementN)`

返回值：当调用该方法时，新的 `length` 属性值将被返回。

```js
// 添加元素到数组
var sports = ["soccer", "baseball"];
var total = sports.push("football", "swimming");

console.log(sports);
// ["soccer", "baseball", "football", "swimming"]

console.log(total);
// 4
```

## Array.prototype.reduce()

`reduce()` 方法对数组中的每个元素按序执行一个由您提供的 `reducer` 函数，每一次运行 `reducer` 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。

第一次执行回调函数时，不存在“上一次的计算结果”。如果需要回调函数从数组索引为 0 的元素开始执行，则需要传递初始值。否则，数组索引为 0 的元素将被作为初始值 `initialValue`，迭代器将从第二个元素开始执行（索引为 1 而不是 0）。

语法：

```js
reduce((previousValue, currentValue) => {});
reduce((previousValue, currentValue, currentIndex) => {});
reduce((previousValue, currentValue, currentIndex, array) => {});
reduce((previousValue, currentValue, currentIndex, array) => {}, initialValue);
reduce(callbackFn);
reduce(callbackFn, initialValue);
reduce(function (previousValue, currentValue) {});
reduce(function (previousValue, currentValue, currentIndex) {});
reduce(function (previousValue, currentValue, currentIndex, array) {});
reduce(function (previousValue, currentValue, currentIndex, array) {},
initialValue);
```

返回值：使用 `“reducer”` 回调函数遍历整个数组后的结果。

```js
const array1 = [1, 2, 3, 4];

// 0 + 1 + 2 + 3 + 4
const initialValue = 0;
const sumWithInitial = array1.reduce(
  (previousValue, currentValue) => previousValue + currentValue,
  initialValue
);

console.log(sumWithInitial); // 10
```


## Array.prototype.reverse()

`reverse()` 方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。


语法：` arr.reverse()`

返回值：颠倒后的数组。


```js
const array1 = ['one', 'two', 'three'];
console.log('array1:', array1); //  ["one", "two", "three"]

const reversed = array1.reverse();
console.log('reversed:', reversed); // ["three", "two", "one"]

console.log('array1:', array1); // ["three", "two", "one"]

```


## Array.prototype.shift()

`shift()` 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。

语法：`arr.shift()`

返回值：从数组中删除的元素; 如果数组为空则返回undefined 。


```js
const array1 = [1, 2, 3];

const firstElement = array1.shift();

console.log(array1); // [2, 3]

console.log(firstElement); // 1
```


## Array.prototype.slice()
`slice()` 方法返回一个新的数组对象，这一对象是一个由 `begin` 和 `end` 决定的原数组的浅拷贝（包括 `begin`，不包括`end`）。原始数组不会被改变。

语法：`arr.slice(begin?, end?)`

返回值：一个含有被提取元素的新数组。

```js
// 返回现有数组的一部分

var fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango'];
var citrus = fruits.slice(1, 3);
// fruits contains ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']
// citrus contains ['Orange','Lemon']
```

## Array.prototype.some()

`some()` 方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试。它返回的是一个 `Boolean` 类型的值。

:::tip 备注
如果用一个空数组进行测试，在任何情况下它返回的都是`false`。
:::

语法：`arr.some(callback(element, index?, array?), thisArg?)`

返回值：数组中有至少一个元素通过回调函数的测试就会返回true；所有元素都没有通过回调函数的测试返回值才会为 false。


```js

// 下面的例子检测在数组中是否有元素大于 10。
function isBiggerThan10(element, index, array) {
  return element > 10;
}

[2, 5, 8, 1, 4].some(isBiggerThan10);  // false
[12, 5, 8, 1, 4].some(isBiggerThan10); // true

// 使用箭头函数测试数组元素的值
[2, 5, 8, 1, 4].some(x => x > 10);  // false
[12, 5, 8, 1, 4].some(x => x > 10); // true


// 判断数组元素中是否存在某个值
// 此例中为模仿 includes()  方法，若元素在数组中存在，则回调函数返回值为 true :

var fruits = ['apple', 'banana', 'mango', 'guava'];

function checkAvailability(arr, val) {
  return arr.some(function(arrVal) {
    return val === arrVal;
  });
}

checkAvailability(fruits, 'kela');   // false
checkAvailability(fruits, 'banana'); // true



// 使用箭头函数判断数组元素中是否存在某个值
var fruits = ['apple', 'banana', 'mango', 'guava'];

function checkAvailability(arr, val) {
  return arr.some(arrVal => val === arrVal);
}

checkAvailability(fruits, 'kela');   // false
checkAvailability(fruits, 'banana'); // true


// ## 将任意值转换为布尔类型

var TRUTHY_VALUES = [true, 'true', 1];

function getBoolean(value) {
  'use strict';

  if (typeof value === 'string') {
    value = value.toLowerCase().trim();
  }

  return TRUTHY_VALUES.some(function(t) {
    return t === value;
  });
}

getBoolean(false);   // false
getBoolean('false'); // false
getBoolean(1);       // true
getBoolean('true');  // true
```


## Array.prototype.sort()
`sort()` 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的`UTF-16` 代码单元值序列时构建的

由于它取决于具体实现，因此无法保证排序的时间和空间复杂性。

语法：`arr.sort(compareFunction?)`


```js
const months = ['March', 'Jan', 'Feb', 'Dec'];
months.sort();
console.log(months); // ["Dec", "Feb", "Jan", "March"]

const array1 = [1, 30, 4, 21, 100000];
array1.sort();
console.log(array1); // [1, 100000, 21, 30, 4]


// sort 方法可以使用 函数表达式 方便地书写：
var numbers = [4, 2, 5, 1, 3];
numbers.sort(function(a, b) {
  return a - b;
});
console.log(numbers);

也可以写成：
var numbers = [4, 2, 5, 1, 3];
numbers.sort((a, b) => a - b);
console.log(numbers);

// [1, 2, 3, 4, 5]


```

## Array.prototype.splice()

`splice()` 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。

语法：`array.splice(start[, deleteCount[, item1[, item2[, ...]]]])`

返回值：由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。


```js
// 从索引 2 的位置开始删除 0 个元素，插入“drum”
var myFish = ["angel", "clown", "mandarin", "sturgeon"];
var removed = myFish.splice(2, 0, "drum");
// 运算后的 myFish: ["angel", "clown", "drum", "mandarin", "sturgeon"]
// 被删除的元素: [], 没有元素被删除


// 从索引 2 的位置开始删除 0 个元素，插入“drum” 和 "guitar"
var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
var removed = myFish.splice(2, 0, 'drum', 'guitar');
// 运算后的 myFish: ["angel", "clown", "drum", "guitar", "mandarin", "sturgeon"]
// 被删除的元素: [], 没有元素被删除


// 从索引 3 的位置开始删除 1 个元素
var myFish = ['angel', 'clown', 'drum', 'mandarin', 'sturgeon'];
var removed = myFish.splice(3, 1);
// 运算后的 myFish: ["angel", "clown", "drum", "sturgeon"]
// 被删除的元素: ["mandarin"]


// 从索引 2 的位置开始删除 1 个元素，插入“trumpet”
var myFish = ['angel', 'clown', 'drum', 'sturgeon'];
var removed = myFish.splice(2, 1, "trumpet");
// 运算后的 myFish: ["angel", "clown", "trumpet", "sturgeon"]
// 被删除的元素: ["drum"]


// 从索引 0 的位置开始删除 2 个元素，插入"parrot"、"anemone"和"blue"
var myFish = ['angel', 'clown', 'trumpet', 'sturgeon'];
var removed = myFish.splice(0, 2, 'parrot', 'anemone', 'blue');
// 运算后的 myFish: ["parrot", "anemone", "blue", "trumpet", "sturgeon"]
// 被删除的元素: ["angel", "clown"]


// 从索引 2 的位置开始删除 2 个元素
var myFish = ['parrot', 'anemone', 'blue', 'trumpet', 'sturgeon'];
var removed = myFish.splice(myFish.length - 3, 2);
// 运算后的 myFish: ["parrot", "anemone", "sturgeon"]
// 被删除的元素: ["blue", "trumpet"]



// 从索引 -2 的位置开始删除 1 个元素
var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
var removed = myFish.splice(-2, 1);
// 运算后的 myFish: ["angel", "clown", "sturgeon"]
// 被删除的元素: ["mandarin"]


// 从索引 2 的位置开始删除所有元素
var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
var removed = myFish.splice(2);
// 运算后的 myFish: ["angel", "clown"]
// 被删除的元素: ["mandarin", "sturgeon"]
```



## Array.prototype.unshift()

`unshift()` 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度（该方法修改原有数组）。


语法：`arr.unshift(element1, ..., elementN)`

返回值：当一个对象调用该方法时，返回其 `length` 属性值。


```js
let arr = [1, 2];
arr.unshift(0); // result of the call is 3, which is the new array length
// arr is [0, 1, 2]

arr.unshift(-2, -1); // the new array length is 5
// arr is [-2, -1, 0, 1, 2]

arr.unshift([-4, -3]); // the new array length is 6
// arr is [[-4, -3], -2, -1, 0, 1, 2]

arr.unshift([-7, -6], [-5]); // the new array length is 8
// arr is [ [-7, -6], [-5], [-4, -3], -2, -1, 0, 1, 2 ]
```