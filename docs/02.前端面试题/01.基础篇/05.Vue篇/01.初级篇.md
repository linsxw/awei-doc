---
title: 初级篇
date: 2022-05-28 14:41:35
permalink: /pages/2f804f/
---

## 关于 Vue

....

## vue 的优点是什么？

- 低耦合。视图（`View`）可以独立于 `Model` 变化和修改
- 可重用性。你可以把一些视图逻辑放在一个 `ViewModel` 里面，让很多 `view` 重用这段视图逻辑。
- 独立开发。开发人员可以专注于业务逻辑和数据的开发（`ViewModel`），设计人员可以专注于页面设计。
- 可测试。界面素来是比较难于测试的，而现在测试可以针对 `ViewModel` 来写。

## 如何让 CSS 只在当前组件中起作用

将当前组件的`<style>`修改为`<style scoped>`

## v-if 和 v-show 区别

`v-if`:

1. v-if 是动态的向 DOM 树内添加或者删除 DOM 元素；
2. v-if 切换有一个局部编译/卸载的过程，切换过程中合适当地销毁和重建内部的事件监听和子组件；
3. v-if 是惰性的，如果初始条件为假则什么也不做，只有在条件第一次变为真时才开始局部编译；
4. v-if 有更高的切换消耗；
5. v-if 适合运营条件不大可能改变的场景；

`v-show`:

1. v-show 是通过设置 DOM 元素的 display 样式属性控制显隐；
2. v-show 只是简单的基于 css 切换；
3. v-show 是在任何条件下都被编译，然后被缓存，而且 DOM 元素保留；
4. v-show 有更高的初始渲染消耗；
5. v-show 适合频繁切换的场景。

::: tip 总结
v-show 只编译一次，后面其实就是控制 css，而 v-if 不停的销毁和创建，如果要频繁切换某节点时，故 v-show 性能更好一点。
:::

## vue 常用的修饰符

- `.prevent`: 阻止默认事件的发生，例如：提交事件不再重载页面；
- `.stop`: 阻止事件进行冒泡；
- `.self`: 元素绑定的事件只会在元素自身触发，而子元素无法调用；
- `.capture`: 事件侦听，事件发生的时候会调用。

## vue 中常用的一些指令

- `v-model`：用于表单输入，实现表单控件和数据的双向绑定；
- `v-on`：简写为@，基础事件绑定；
- `v-bind`：简写为：，动态绑定一些元素的属性，类型可以是：字符串、对象或数组；
- `v-if`：作用与 js 中的`if`语句相似，可以在实例中定义判断语句，也可以在`dom`处直接定义三元运算，取值为`true/false`，控制元素是否需要被渲染，可以与`v-else` 配合使用；
- `v-else`指令：和`v-if`指令搭配使用，没有对应的值。当`v-if`的值`false`，`v-else`才会被渲染出来；
- `v-else-if`：必须和 `v-if` 配合使用，作用与 `else-if` 相似；
- `v-show`指令：指令的取值为`true/false`，分别对应着显示/隐藏；
- `v-for`指令：遍历 data 中存放的数组数据，实现列表的渲染；
- `v-once`： 通过使用 `v-once` 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新；
- `v-pre`：正文中包含了不希望被`vue`编译的{{ }}时，采用 v-pre 保护；
- `v-html`：绑定一段 HTML 代码片段到页面上。

## 为什么避免 v-if 和 v-for 一起使用？

当 Vue 处理指令时，v-for 比 v-if 具有更高的优先级，通过 v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。

## Vue 的生命周期

### 什么是生命周期

Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom 渲染 更新 渲染 卸载等一系列过程，我们称这是 Vue 的生命周期。

### 生命周期各阶段的作用

- `beforeCreate`（创建前）数据观测和初始化事件还未开始；
- `created`（创建后）完成数据观测，属性和方法的运算，初始化事件，$el 属性还未显示出来；
- `beforeMount`（挂载前）在挂载开始之前被调用，相关的 render 函数首次被调用，实例已完成以下的配置：编译模板，把 data 里面的数据和模板生成 html；注意此时还没有挂载 html 到页面上；
- `mounted`（挂载后）el 被新创建的 vm.$el 替换，并挂载到实例上去调用。实例已完成以下的配置：用上面编译好的 html 内容替换 el 属性指向的 DOM 对象。完成模板中的 html 渲染到 html 页面中。此过程中进行 ajax 交互；
- `beforeUpdate`（更新前） 在数据更新之前调用，发生在虚拟 DOM 重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程；
- `updated`（更新后） 在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用；
- `beforeDestroy`（销毁前） 在实例销毁之前调用，实例仍然完全可用；
- `destroyed`（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。

## 可以在哪个生命周期内调用异步请求？

一般来说，可以在 `created`, `mounted` 中都可以发送数据请求，但是，大部分时候，会在 `created` 发送请求
`Created` 的使用场景：如果页面首次渲染的就来自后端数据。因为，此时 `data` 已经挂载到 `vue` 实例了。
可以在钩子函数 `created`、`beforeMount`、`mounted`中进行调用，因为在这三个钩子函数中，`data`已经创建，可以将服务端端返回的数据进行赋值。但最常用的是在`created`钩子函数中调用异步请求，因为在`created`钩子函数中调用异步请求
有两个优点：

1. 能更快获取到服务端数据，减少页面 loading 时间；
2. 放在 created 中有助于一致性，因为`ssr`不支持`beforeMount`、`mounted`钩子函数。

## $nextTick 的理解

用法：
在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。

为什么？

Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。
所以为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用。

使用场景

在你更新完数据后，需要及时操作渲染好的 DOM 时

## Vue.set 改变数组和对象中的属性

在一个组件实例中，只有在 `data` 里初始化的数据才是响应的，`Vue` 不能检测到对象属性的添加或删除，没有在 `data` 里声明的属性不是响应的,所以数据改变了但是不会在页面渲染；
解决办法：
使用 `Vue.set(object, key, value)` 方法将响应属性添加到嵌套的对象上

## vm.$set(obj, key, val) 做了什么？

由于 `Vue` 无法探测对象新增属性或者通过索引为数组新增一个元素，所以这才有了`vm.set`， 它 是 `Vue.set` 的 别 名 。 `vm.set`，它是 Vue.set 的别名。 `vm.set`，它是` Vue.set` 的别名。`vm.set` 用于向响应式对象添加一个新的 `property`，并确保这个新的 `property` 同样是响应式的，并触发视图更新。

为对象添加一个新的响应式数据：调用 `defineReactive` 方法为对象增加响应式数据，然后执行 `dep.notify` 进行依赖通知，更新视图
为数组添加一个新的响应式数据：通过 `splice` 方法实现

## Vue 组件通信有哪些方式？

1. 父传子：`props`
   父组件通过 `props` 向下传递数据给子组件。注：组件中的数据共有三种形式：`data`、`props`、`computed`

2. 父传子孙：`provide` 和 `inject`
   父组件定义`provide`方法`return`需要分享给子孙组件的属性，子孙组件使用 `inject` 选项来接收指定的我们想要添加在这个实例上的 属性；

3. 子传父：通过事件形式
   子组件通过 `$emit()`给父组件发送消息，父组件通过`v-on`绑定事件接收数据。

4. 父子、兄弟、跨级：`eventBus.js`
   这种方法通过一个空的 `Vue` 实例作为中央事件总线（事件中心）,用它来（`emit`） 触 发 事 件 和 （`emit`）触发事件和（`emit`）触发事件和（`on`）监听事件，巧妙而轻量地实现了任何组件间的通信。

5. 通信插件：`PubSub.js`

6. vuex
   `vuex` 是 `vue` 的状态管理器，存储的数据是响应式的。只需要把共享的值放到`vuex`中，其他需要的组件直接获取使用即可；
