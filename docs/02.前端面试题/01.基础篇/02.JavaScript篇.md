---
title: JavaScript基础篇面试题大全
date: 2022-05-26 22:34:30
permalink: /pages/297d8c/
---

## JS 的基本数据类型有哪些？

`number`、`string`、`bootlean`、`null`、`undefined`、`Bigint` 、`Symbol`

## 基本类型和引用类型

`String`、`Boolean`、`Number`、`Null`、`Undefined`、`Symbol`,还有一个还没有被正式纳入标准的`BigInt`。
`Symbol`可以用来创建唯一常量。

- 基本类型的值不能被方法来改变，只能通过赋值的方式来改变，所谓“赋值”就是“指针指向的改变”，
- 基本数据类型的值不能添加方法和属性
- 一个变量向另一个变量赋值，是会在变量对象上创建新值，把新值复制到新变量分配到位置上，两个变量独立且不互相影响
- 基本数据类型的比较是值的比较
- 基本数据类型是存放在栈区的，变量的标识符和变量的值

**引用类型**
引用类型统称为`Object` 类型，细分的话包括`Object` 类型、`Array` 类型、`Date` 类型、`RegExp` 类型、`Function` 类型

- 引用类型的值是可以改变的
- 引用类型可以添加属性和方法
- 引用类型的值是按照引用访问的，当从一个变量向另一个变量赋值引用类型的值时，同样也会将储存在变量中的对象的值复制一份放到为新变量分配的空间中.引用类型保存在变量中的是对象在堆内存中的地址，所以，与基本数据类型的简单赋值不同，这个值的副本实际上是一个指针，而这个指针指向存储在堆内存的一个对象.那么赋值操作后，两个变量都保存了同一个对象地址，而这两个地址指向了同一个对象.因此，改变其中任何一个变量，都会互相影响
- 引用类型的比较是引用的比较
- 引用类型的值是同时保存在栈区和堆区中的

**基本包装类型**：字符串是基本类型，按理说不该有方法，但我们可以调用 `split()`等等方法，主要是因为 `ECMAScript` 还提供了三个特殊的引用类型` Boolean`,`String`,`Number`.我们称这三个特殊的引用类型为基本包装类型，也叫包装对象.

也就是说当读取 `string`,`boolean` 和 `number` 这三个基本数据类型的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据，最后再销毁基本包装类型的实例。正因为有这个销毁的动作，所以基本数据类型不可以添加属性和方法，

**生存周期**： 对象的生存期，使用 `new` 操作符创建的引用类型的实例，在执行流离开当前作用域之前都是一直保存在内存中；而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁

## 常见的内置对象

`Object`是所有对象的父对象
数据封装类对象：`Object` 、 `Array` 、 `Boolean` 、 `Number` 和 `String`
其他对象：`function`、`Arguments math date`

## 装箱和拆箱

> 装箱： 基本数据类型转换为对应的引用类型的操作

- 隐式装箱： 在基本数据类型调用一些方法时，后台会创建对应的基本包装类型实例来操作，最后再销毁，这个过程就是个装箱
- 显式装箱： 当我们显式得把字符串传入 new String()时就是显式装箱

> 拆箱

- 拆箱就和装箱相反，是指把引用类型转换成基本的数据类型，JS 标准规定了`ToPrimitive`用于拆箱转换。

## 作用域和作用域链

作用域就是我们声明的函数或变量的可访问范围就是作用域
作用域链就是放我们在访问一个变量的时候 当前作用域没有 就会往上一层的作用域访问 直到访问`window`为值

## 原型和原型链

每个对象都会在其内部初始化一个属性，prototype，这个就是原型
当我们访问一个方法的时候，当前的对象没有 就会往他的原型上继续查找，这个 prototype 也有自己的原型 一直往上 直到找到 object 为止 这个一层一层往上找就是原型链

```javascript
function pro() {
  this.name = "张三";
}
pro.prototype.name = "里斯";
var a = new pro();
console.log(a.name);
console.log(a.__proto__ === pro.prototype); // true
```

## new 一个对象发生了什么？

1. 创建空对象
2. 把函数的原型给到空对象
3. 修改 this 指向
4. 返回值

```javascript
function new(fn,...agrs){
	let obj = {}
	Object.setPrototypeOf(obj,fn.prototype)
	let res = fn.apply(obj,...agrs)
	return typeof res ==== 'object'?res :obj
}
```

## 什么是事件委托？

- 事件委托就是利用冒泡的原理，将事件加到 父元素 或 祖先元素上，触发执行效果。

例如： 在 document 中绑定 click 事件，当 click 的对象为 按钮 btn 时，弹框显示 按钮 btn 的值

```html
<body>
  <button id="btn" value="嘿嘿">哈哈</button>
  <script>
    window.onload = function () {
      let btn = document.getElementById("btn");
      document.onclick = function (e) {
        // console.log(e.target)
        if (e.target === btn) {
          alert(btn.value);
        }
      };
    };
  </script>
</body>
```

- 事件委托的优点

1. 可以提高 JS 性能
   例：在 ul 上创建 100 个 li，点击每个 li 都要弹框显示该 li 的 value
   传统写法：在每个 li 上都绑定 onclick 事件，并触发 alert 事件
   事件委托：在 document 上绑定 onclick 事件，当触发 onclick 事件后，判断是不是 <li> 标签，如果是，则 alert <li> 标签的值。

2. 可以动态添加 DOM 元素，不需要因为元素的变动而修改事件绑定。

- 事件委托需要注意的地方

![](https://img.jbzj.com/file_images/article/202008/2020829163301802.png?2020729163320)

如图，事件冒泡是从子元素向父元素传递事件，一层一层，事件委托就是利用了冒泡原理；事件捕获是从 DOM 最高层对象一层一层往子元素传播。

## null 和 undefined 有什么区别？

- `null`表示“没有对象”，即该处不应该有值
- `undefined`表示“缺少值”，此处应该有一个值，只是没有定义

## 轮询和长轮询

- **轮训：**客户端定时向服务器发送请求，服务器接收到请求后马上返回响应信息并关闭连接。
- **长轮询：**客户端向服务器发送请求，服务器接收到请求之后并不马上响应，等待资源更新时再响应并关闭连接。

轮询请求大半无用，浪费带宽，适用于中小项目。
长轮询看起来美好，但占用服务器资源，用于实时性比较高的项目，比如 WebQQ。

## Array.map、reduce、foreach、filter 区别

- `foreach` 按顺序传入每个值，不返回内容
- `reduce`，将每个值从第二个参数中获取，在第一个参数中保存
- `filter` 过滤器，只返回符合条件的值
- `map` 按顺序传入每个值，`return` 的值改变当前值

> `filter` 和 `map` 是返回新数组，`reduce` 返回结果值，`foreach` 不返回

## 深拷贝和浅拷贝（待补充实现）

- 浅拷贝（shallow copy）：只复制指向某个对象的指针，而不复制对象本身，新旧对象共享一块内存；
- 深拷贝（deep copy）：复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变。

## 同步和异步

我们可以通俗理解为异步就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有”堵塞“效应。不连续的执行，就叫做异步。相应地，连续的执行，就叫做同步

"异步模式"非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是 Ajax 操作。在服务器端，"异步模式"甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有 http 请求，服务器性能会急剧下降，很快就会失去响应。

## 声明一个函数有几种方式，有什么区别

**函数式声明**

```js
//ES5
funciton name(){}
function (){}//匿名函数
//ES6
()=>{}
```

**函数表达式（函数字面量）**

```js
let fun = function () {};
let fun = () => {};
let fun = (function name() {})(function name() {})();
```

**Function 构造**

let fun = new Function('arg1','arg2','alert(arg1+","+arg2)')

**区别：**

- 构造函数需要被解析两次，第一次解析 js 代码，第二次解析传入构造函数的字符串，影响性能。
- 基于变量提升和函数提升的机制，函数的声明优先级更高，会直接提升当前作用域的顶端，然后表达式和变量按顺序执行。
