---
title: JavaScript基础篇面试题大全
date: 2022-05-26 22:34:30
permalink: /pages/297d8c/
---

## JS 的基本数据类型有哪些？

`number`、`string`、`bootlean`、`null`、`undefined`、`Bigint` 、`Symbol`

## 基本类型和引用类型

`String`、`Boolean`、`Number`、`Null`、`Undefined`、`Symbol`,还有一个还没有被正式纳入标准的`BigInt`。
`Symbol`可以用来创建唯一常量。

- 基本类型的值不能被方法来改变，只能通过赋值的方式来改变，所谓“赋值”就是“指针指向的改变”，
- 基本数据类型的值不能添加方法和属性
- 一个变量向另一个变量赋值，是会在变量对象上创建新值，把新值复制到新变量分配到位置上，两个变量独立且不互相影响
- 基本数据类型的比较是值的比较
- 基本数据类型是存放在栈区的，变量的标识符和变量的值

**引用类型**
引用类型统称为`Object` 类型，细分的话包括`Object` 类型、`Array` 类型、`Date` 类型、`RegExp` 类型、`Function` 类型

- 引用类型的值是可以改变的
- 引用类型可以添加属性和方法
- 引用类型的值是按照引用访问的，当从一个变量向另一个变量赋值引用类型的值时，同样也会将储存在变量中的对象的值复制一份放到为新变量分配的空间中.引用类型保存在变量中的是对象在堆内存中的地址，所以，与基本数据类型的简单赋值不同，这个值的副本实际上是一个指针，而这个指针指向存储在堆内存的一个对象.那么赋值操作后，两个变量都保存了同一个对象地址，而这两个地址指向了同一个对象.因此，改变其中任何一个变量，都会互相影响
- 引用类型的比较是引用的比较
- 引用类型的值是同时保存在栈区和堆区中的

**基本包装类型**：字符串是基本类型，按理说不该有方法，但我们可以调用 `split()`等等方法，主要是因为 `ECMAScript` 还提供了三个特殊的引用类型` Boolean`,`String`,`Number`.我们称这三个特殊的引用类型为基本包装类型，也叫包装对象.

也就是说当读取 `string`,`boolean` 和 `number` 这三个基本数据类型的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据，最后再销毁基本包装类型的实例。正因为有这个销毁的动作，所以基本数据类型不可以添加属性和方法，

**生存周期**： 对象的生存期，使用 `new` 操作符创建的引用类型的实例，在执行流离开当前作用域之前都是一直保存在内存中；而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁

## NaN 是什么

NaN 即非数值（Not a Number），NaN 属性用于引用特殊的非数字值，该属性指定的并不是不合法的数字。

NaN 属性 与 Number.Nan 属性相同。

::: tip
提示： 请使用 isNaN() 来判断一个值是否是数字。原因是 NaN 与所有值都不相等，包括它自己。
:::

## 常见的内置对象

`Object`是所有对象的父对象
数据封装类对象：`Object` 、 `Array` 、 `Boolean` 、 `Number` 和 `String`
其他对象：`function`、`Arguments math date`

## 装箱和拆箱

> 装箱： 基本数据类型转换为对应的引用类型的操作

- 隐式装箱： 在基本数据类型调用一些方法时，后台会创建对应的基本包装类型实例来操作，最后再销毁，这个过程就是个装箱
- 显式装箱： 当我们显式得把字符串传入 new String()时就是显式装箱

> 拆箱

- 拆箱就和装箱相反，是指把引用类型转换成基本的数据类型，JS 标准规定了`ToPrimitive`用于拆箱转换。

## 作用域和作用域链

作用域就是我们声明的函数或变量的可访问范围就是作用域
作用域链就是放我们在访问一个变量的时候 当前作用域没有 就会往上一层的作用域访问 直到访问`window`为值

## 原型和原型链

每个对象都会在其内部初始化一个属性，prototype，这个就是原型
当我们访问一个方法的时候，当前的对象没有 就会往他的原型上继续查找，这个 prototype 也有自己的原型 一直往上 直到找到 object 为止 这个一层一层往上找就是原型链

```javascript
function pro() {
  this.name = "张三";
}
pro.prototype.name = "里斯";
var a = new pro();
console.log(a.name);
console.log(a.__proto__ === pro.prototype); // true
```

## new 一个对象发生了什么？

1. 创建空对象
2. 把函数的原型给到空对象
3. 修改 this 指向
4. 返回值

```javascript
function new(fn,...agrs){
	let obj = {}
	Object.setPrototypeOf(obj,fn.prototype)
	let res = fn.apply(obj,...agrs)
	return typeof res ==== 'object'?res :obj
}
```

## javascript 中 this 的指向

`this` 永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。

普通的函数调用，函数被谁调用，`this` 就是谁。

构造函数的话，如果不用 `new` 操作符而直接调用，那即 `this` 指向 `window`。用 `new` 操作符生成对象实例后，`this` 就指向了新生成的对象。

匿名函数或不处于任何对象中的函数指向 `window` 。

如果是 `call`，`apply` 等，指定的 `this` 是谁，就是谁。

## 谈谈 this 的理解

1. `this` 总是指向函数的直接调用者（而非间接调用者）

2. 如果有 `new` 关键字，`this` 指向 `new` 出来的那个对象

3. 在事件中，`this` 指向目标元素，特殊的是 `IE` 的 `attachEvent` 中的 `this` 总是指向全局对象 `window`。

## call，apply，bind 的区别

`call` `apply` `bind` 都可以改变函数调用的 `this` 指向。

函数.call(对象,arg1,arg2....)函数.apply(对象，[arg1,arg2,...])var ss=函数.bind(对象,arg1,arg2,....)

1.第一个参数都是指定函数内部中 `this` 的指向（函数执行时所在的作用域），然后根据指定的作用域，调用该函数。

2.都可以在函数调用时传递参数。`call`，`bind` 方法需要直接传入，而 `apply` 方法需要以数组的形式传入。

3.`call`，`apply` 方法是在调用之后立即执行函数，而 `bind` 方法没有立即执行，需要将函数再执行一遍。

4.改变 this 对象的指向问题不仅有 `call`，`apply`，`bind` 方法，也可以使用 that 变量来固定 `this` 的指向。

## 什么是事件委托？

- 事件委托就是利用冒泡的原理，将事件加到 父元素 或 祖先元素上，触发执行效果。

例如： 在 document 中绑定 click 事件，当 click 的对象为 按钮 btn 时，弹框显示 按钮 btn 的值

```html
<body>
  <button id="btn" value="嘿嘿">哈哈</button>
  <script>
    window.onload = function () {
      let btn = document.getElementById("btn");
      document.onclick = function (e) {
        // console.log(e.target)
        if (e.target === btn) {
          alert(btn.value);
        }
      };
    };
  </script>
</body>
```

- 事件委托的优点

1. 可以提高 JS 性能
   例：在 ul 上创建 100 个 li，点击每个 li 都要弹框显示该 li 的 value
   传统写法：在每个 li 上都绑定 onclick 事件，并触发 alert 事件
   事件委托：在 document 上绑定 onclick 事件，当触发 onclick 事件后，判断是不是 <li> 标签，如果是，则 alert <li> 标签的值。

2. 可以动态添加 DOM 元素，不需要因为元素的变动而修改事件绑定。

- 事件委托需要注意的地方

![](https://img.jbzj.com/file_images/article/202008/2020829163301802.png?2020729163320)

如图，事件冒泡是从子元素向父元素传递事件，一层一层，事件委托就是利用了冒泡原理；事件捕获是从 DOM 最高层对象一层一层往子元素传播。

## null 和 undefined 有什么区别？

- `null`表示“没有对象”，即该处不应该有值
- `undefined`表示“缺少值”，此处应该有一个值，只是没有定义

## 轮询和长轮询

- **轮训** ：客户端定时向服务器发送请求，服务器接收到请求后马上返回响应信息并关闭连接。
- **长轮询**：客户端向服务器发送请求，服务器接收到请求之后并不马上响应，等待资源更新时再响应并关闭连接。

轮询请求大半无用，浪费带宽，适用于中小项目。
长轮询看起来美好，但占用服务器资源，用于实时性比较高的项目，比如 WebQQ。

## Array.map、reduce、foreach、filter 区别

- `foreach` 按顺序传入每个值，不返回内容
- `reduce`，将每个值从第二个参数中获取，在第一个参数中保存
- `filter` 过滤器，只返回符合条件的值
- `map` 按顺序传入每个值，`return` 的值改变当前值

> `filter` 和 `map` 是返回新数组，`reduce` 返回结果值，`foreach` 不返回

## 深拷贝和浅拷贝（待补充实现）

- 浅拷贝（shallow copy）：只复制指向某个对象的指针，而不复制对象本身，新旧对象共享一块内存；
- 深拷贝（deep copy）：复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变。

## 同步和异步

我们可以通俗理解为异步就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有”堵塞“效应。不连续的执行，就叫做异步。相应地，连续的执行，就叫做同步

"异步模式"非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是 Ajax 操作。在服务器端，"异步模式"甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有 http 请求，服务器性能会急剧下降，很快就会失去响应。

## 声明一个函数有几种方式，有什么区别

**函数式声明**

```js
//ES5
funciton name(){}
function (){}//匿名函数
//ES6
()=>{}
```

**函数表达式（函数字面量）**

```js
let fun = function () {};
let fun = () => {};
let fun = (function name() {})(function name() {})();
```

**Function 构造**

`let fun = new Function('arg1','arg2','alert(arg1+","+arg2)')`

**区别：**

- 构造函数需要被解析两次，第一次解析 js 代码，第二次解析传入构造函数的字符串，影响性能。
- 基于变量提升和函数提升的机制，函数的声明优先级更高，会直接提升当前作用域的顶端，然后表达式和变量按顺序执行。

## for..in 和 object.keys 的区别

`Object.keys` 不会遍历继承的原型属性

`for...in` 会遍历继承的原型属性

## 响应事件有哪些？

`onclick`鼠标点击某个对象；`onfocus`获取焦点；`onblur`失去焦点；`onmousedown`鼠标被按下等，常用的如下：

- 鼠标单击事件（ `onclick` ）
- 鼠标经过事件（ `onmouseover` ）
- 鼠标移开事件（ `onmouseout` ）
- 光标聚焦事件（ `onfocus` ）
- 失焦事件（ `onblur` ）
- 内容选中事件（ `onselect` ）
- 文本框内容改变事件（ `onchange` ）
- 加载事件（ `onload` ）
- 卸载事件（ `onunload` ）

## 闭包的概念？优缺点？使用场景？

闭包的概念：闭包就是能读取其他函数内部变量的函数。

避免全局变量的污染
希望一个变量长期存储在内存中（缓存变量）

缺点：

- 内存泄露（消耗）
- 常驻内存，增加内存使用量
- 使用场景：封装功能时(需要使用私有的属性和方法)，函数防抖、函数节流、函数柯里化、给元素伪数组添加事件需要使用元素的索引值。

## 造成内存泄露的原因

1. 意外的全局变量(在函数内部没有使用 var 进行声明的变量)
2. console.log
3. 闭包
4. 对象的循环引用
5. 未清除的计时器
6. DOM 泄露(获取到 DOM 节点之后，将 DOM 节点删除，但是没有手动释放变量，拿对应的 DOM 节点在变量中还可以访问到，就会造成泄露)

## Javascript 原型链

首先理解三个概念：

`prototype`：原型对象，每个函数都有一个 `prototype` 属性，再通过 new 命令实例对象时，该属性会成为该实例的原型对象。
`constructor`：构造函数。指向原型对象的 `constructor`
`__proto__`：实例对象的原型
在 `javascript` 中，实例对象与原型之间的链接，叫做原型链。`Javascript` 解析引擎在读取一个`Object`的属性的值时，会沿着原型链向上寻找，如果最终没有找到，则该属性值为`undefined`；如果最终找到该属性的值，则返回结果。

## document.onload 和 document.ready 两个事件的区别

页面加载完成有两种事件

一是`ready`，表示文档结构已经加载完成（不包含图片等非文字媒体文件）

二是`onload`，指示页面包含图片等文件在内的所有元素都加载完成。

## 什么是"use strict";?使用它的好处和坏处分别是什么？

在代码中出现表达式-`"use strict"`; 意味着代码按照严格模式解析，这种模式使得`Javascript`在更严格的条件下运行。

**好处**：

- 消除`Javascript`语法的一些不合理、不严谨之处，减少一些怪异行为;
- 消除代码运行的一些不安全之处，保证代码运行的安全；
- 提高编译器效率，增加运行速度；
- 为未来新版本的`Javascript`做好铺垫。

**坏处**：

- 同样的代码，在"严格模式"中，可能会有不一样的运行结果；
- 一些在"正常模式"下可以运行的语句，在"严格模式"下将不能运行。

## 什么是跨域？有什么方法解决跨域带来的问题？

跨域需要针对浏览器的同源策略来理解，同源策略指的是请求必须是同一个端口，同一个协议，同一个域名，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。受浏览器同源策略的影响，不是同源的脚本不能操作其他源下面的对象。想要操作另一个源下的对象是就需要跨域。

常用解决方案：

- 跨域资源共享（`CORS`）
- `nginx`代理跨域
- `nodejs`中间件代理跨域
- `jsonp`跨域

## 解释什么是 Json

1. `JSON` 是一种轻量级的数据交换格式。

2. `JSON` 独立于语言和平台，`JSON` 解析器和 `JSON` 库支持许多不同的编程语言。

3. `JSON` 的语法表示三种类型值，简单值(字符串，数值，布尔值，`null`),数组，对象

## 谈谈 Cookie 的弊端?

1. Cookie 数量和长度的限制。每个 `domain` 最多只能有 `20` 条` cookie`，每个 `cookie` 长度不能超过 `4KB`，否则会被截掉。

2. 安全性问题。如果 `cookie` 被 人拦截了，那人就可以取得所有的 `session` 信息。即使加密也与事无补，因为拦截者并不需要知道 `cookie` 的意义，他只要原样转发 `cookie` 就可以达到目的了。

3. 有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。

## 描述一下 cookies，sessionStorage 和 localStorage 的区别？

**cookies**

Cookies 是一些数据, 存储于你电脑上的文本文件中。当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。Cookies 的作用就是用于解决 "如何记录客户端的用户信息":

- 当用户访问 web 页面时，他的名字可以记录在 cookie 中。
- 在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。
- cookies 以名值对形式存储：username=harry
- 当浏览器从服务器上请求 web 页面时， 属于该页面的 cookies 会被添加到该请求中。服务端通过这种方式来获取用户的信息。

**sessionStorage,localStorage**

- 通过本地存储（`Local Storage`），`web` 应用程序能够在用户浏览器中对数据进行本地的存储。
- 在 `HTML5` 之前，应用程序数据只能存储在 `cookie` 中，包括每个服务器请求。本地存储则更安全，并且可在不影响网站性能的前提下将大量数据存储于本地。
- 与 `cookie` 不同，存储限制要大得多（至少 `5MB`），并且信息不会被传输到服务器。
- 本地存储经由起源地（`origin`）（经由域和协议）。所有页面，从起源地，能够存储和访问相同的数据。
- `localStorage` 对象存储的是没有截止日期的数据。当浏览器被关闭时数据不会被删除，在下一天、周或年中，都是可用的。
- `sessionStorage` 对象等同 `localStorage` 对象，不同之处在于只对一个 `session` 存储数据。如果用户关闭具体的浏览器标签页，数据也会被删除。

**三者的区别**

- `cookie` 会随请求发送到服务器，作为会话表示，服务器可修改 `cookie`
- `cookie` 有 path 的概念，子路径可以访问父路径的 `cookie`，父路径不可以访问子路径的 `cookie`
- `sessionStorage` 不能共享，`localStorage` 在同源文档之间可以共享，`cookie` 在同源且符合 `path` 规则的文档之间可以共享
- `localStorage` 的修改会触发其他文档的 update 事件
- `cookie` 有 `secure` 属性要求 `HTTPS` 传输

**存储大小**

- `cookie` 数据大小不能超过`4K`。
- `sessionStorage` 和 `localStorage` 虽然也有存储大小的限制，但比 `cookie` 大得多，可以达到 `5M` 或更大。

**有效时间**

- `cookie` 设置的 `cookie` 过期时间之前一直有效，即使窗口或浏览器关闭
- `sessionStorage` 数据在当前浏览器窗口关闭后自动删除
- `localStorage` 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据

[详细参考文章（W3C）](https://www.w3school.com.cn/html/html5_webstorage.asp)

## 数组对象有哪些原生方法，列举一下

`pop`、`push`、`shift`、`unshift`、`splice`、`reverse`、`sort`、`concat`、`join`、`slice`、`toString`、`indexOf`、`lastIndexOf`、`reduce`、`reduceRight`、`forEach`、`map`、`filter`、`every`、`some`

`pop`：删除并返回数组最后一个元素（改变原数组）；
`push`：返回添加完成后的数组的长度（改变原数组）；
`shift`：移除并返回数组的第一个元素（改变原数组）；
`unshift`:在数组头部插入一个元素`slice`：`slice`(下标，个数)返回裁剪后的数组（不改变原数组）；
`splice`：插入，删除或替换数组的元素 `concat`：合并数组返回组合数组（不改变原数组）；
`join`：将数组用标识符链接成字符串返回拼接好的字符串（不改变原数组）；
`reverse`：翻转数组（改变原数组）；`toString`:将数组转换成一个字符串；
`split`：把字符串分割开，以数组方式储存；`forEach`：主要用于遍历数组；
`every`：主要用于检查数组中每个元素是否符合函数的条件，如果其中有一个不符合，则返回 `false`；`indexOf`：主要用于在数组中查找元素，并把元素的位置返回来。

## 字符串方法有哪些？

`charAt()`：根据下标找到对应值

`charCodeAt()`：通过下标值找到对应字符 `Unicode` 编码

`indexOf()`：通过字符查找对应下标（首次出现）

`lastIndexOf()`：通过字符找最后一次出现的下标值

`slice()`：截取字符串，2 个参数，（起始位置，结束位置）

`split()`：把字符串按分隔符分割成数组

`substring()`：截取字符串，（起始位置，结束位置）

`substr()`：截取指定位置和长度的字符串，（起始位置，长度）

`toLowerCase()`：字符串转为小写

`toUpperCase()`：字符串转成大写

`trim()`：去掉字符串前后所有空格
